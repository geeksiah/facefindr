'use server';

import { revalidatePath } from 'next/cache';
import { headers } from 'next/headers';
import { redirect } from 'next/navigation';

import { getAdminAppUrl, getAppUrl } from '@/lib/env';
import { createClient, createServiceClient } from '@/lib/supabase/server';
import { isCreatorUser, normalizeUserType, type AcceptedUserType } from '@/lib/user-type';
import {
  loginSchema,
  registerSchema,
  forgotPasswordSchema,
  resetPasswordSchema,
  type LoginInput,
  type RegisterInput,
  type ForgotPasswordInput,
  type ResetPasswordInput,
} from '@/lib/validations/auth';

// ============================================
// HELPER FUNCTION FOR GENERATING FACE TAG
// Note: This is now mostly handled by database triggers
// using the username field, but kept as fallback
// ============================================

function generateFaceTagFallback(displayName: string): { faceTag: string; suffix: string } {
  // Generate a 4-digit random suffix
  const suffix = Math.floor(1000 + Math.random() * 9000).toString();
  
  // Clean the display name: lowercase, remove spaces and special chars
  const cleanName = displayName
    .toLowerCase()
    .replace(/[^a-z0-9]/g, '')
    .slice(0, 8);
  
  // Format: @username0001 (new format without dot)
  const faceTag = `@${cleanName}${suffix.padStart(4, '0')}`;
  
  return { faceTag, suffix };
}

function normalizeCountryCode(value: unknown): string | null {
  if (typeof value !== 'string') return null;
  const code = value.trim().toUpperCase();
  return /^[A-Z]{2}$/.test(code) ? code : null;
}

function getCountryFromHeaders(requestHeaders: { get(name: string): string | null }): string | null {
  const country =
    requestHeaders.get('x-vercel-ip-country') ||
    requestHeaders.get('cf-ipcountry') ||
    requestHeaders.get('x-country-code');
  return normalizeCountryCode(country);
}

function isMissingColumnError(error: any, columnName: string) {
  return error?.code === '42703' && typeof error?.message === 'string' && error.message.includes(columnName);
}

async function insertProfileWithCountryFallback(
  adminDb: any,
  table: 'photographers' | 'attendees',
  payload: Record<string, any>
) {
  const withCountry = await adminDb.from(table).insert(payload);
  if (!withCountry.error) {
    return withCountry;
  }

  if (!isMissingColumnError(withCountry.error, 'country_code')) {
    return withCountry;
  }

  const { country_code, ...fallbackPayload } = payload;
  return adminDb.from(table).insert(fallbackPayload);
}

// ============================================
// LOGIN ACTION
// ============================================

export async function login(formData: LoginInput) {
  const validated = loginSchema.safeParse(formData);
  
  if (!validated.success) {
    return {
      error: validated.error.errors[0]?.message || 'Invalid input',
    };
  }

  const supabase = await createClient();
  
  const { error } = await supabase.auth.signInWithPassword({
    email: validated.data.email,
    password: validated.data.password,
  });

  if (error) {
    return {
      error: error.message === 'Invalid login credentials' 
        ? 'Invalid email or password' 
        : error.message,
    };
  }

  revalidatePath('/', 'layout');
  redirect('/dashboard');
}

// ============================================
// REGISTER ACTION
// ============================================

export async function register(formData: RegisterInput) {
  const appUrl = getAppUrl();
  const validated = registerSchema.safeParse(formData);
  
  if (!validated.success) {
    return {
      error: validated.error.errors[0]?.message || 'Invalid input',
    };
  }

  const supabase = await createClient();
  const serviceClient = createServiceClient();
  const adminDb = serviceClient as any;
  const requestHeaders = headers();
  const countryCode =
    normalizeCountryCode(validated.data.countryCode) || getCountryFromHeaders(requestHeaders);
  const normalizedUserType = normalizeUserType(validated.data.userType);
  if (!normalizedUserType) {
    return { error: 'Invalid account type' };
  }
  
  // Sign up the user with Supabase Auth
  const { data: authData, error: signUpError } = await supabase.auth.signUp({
    email: validated.data.email,
    password: validated.data.password,
    options: {
      emailRedirectTo: `${appUrl}/auth/callback`,
      data: {
        display_name: validated.data.displayName,
        user_type: normalizedUserType,
        username: validated.data.username, // Used by DB trigger for FaceTag generation
        country_code: countryCode,
      },
    },
  });

  if (signUpError) {
    if (signUpError.message.includes('already registered')) {
      return { error: 'An account with this email already exists' };
    }
    return { error: signUpError.message };
  }

  if (!authData.user) {
    return { error: 'Failed to create account' };
  }

  // Create the profile in the appropriate table
  // Note: FaceTag is generated by database trigger using the username from user_metadata
  if (isCreatorUser(normalizedUserType)) {
    const { error: profileError } = await insertProfileWithCountryFallback(adminDb, 'photographers', {
        id: authData.user.id,
        user_id: authData.user.id,
        email: validated.data.email,
        display_name: validated.data.displayName,
        username: validated.data.username,
        country_code: countryCode,
        status: 'pending_verification',
        email_verified: false,
        // face_tag will be generated by trigger
      });

    if (profileError) {
      console.error('Failed to create photographer profile:', profileError);
      // Don't return error - user is created, profile will be created on verification
    }

    // Create a free subscription for the photographer
    await adminDb.from('subscriptions').insert({
      photographer_id: authData.user.id,
      plan_code: 'free',
      status: 'active',
    });
  } else {
    const { error: profileError } = await insertProfileWithCountryFallback(adminDb, 'attendees', {
        id: authData.user.id,
        user_id: authData.user.id,
        email: validated.data.email,
        display_name: validated.data.displayName,
        username: validated.data.username,
        country_code: countryCode,
        status: 'active',
        email_verified: false,
        // face_tag will be generated by trigger
      });

    if (profileError) {
      console.error('Failed to create attendee profile:', profileError);
    }
  }

  return {
    success: true,
    message: 'Please check your email to verify your account',
  };
}

// ============================================
// FORGOT PASSWORD ACTION
// ============================================

export async function forgotPassword(formData: ForgotPasswordInput) {
  const appUrl = getAppUrl();
  const validated = forgotPasswordSchema.safeParse(formData);
  
  if (!validated.success) {
    return {
      error: validated.error.errors[0]?.message || 'Invalid input',
    };
  }

  const supabase = await createClient();
  
  const { error } = await supabase.auth.resetPasswordForEmail(validated.data.email, {
    redirectTo: `${appUrl}/reset-password`,
  });

  if (error) {
    return { error: error.message };
  }

  return {
    success: true,
    message: 'If an account exists with this email, you will receive a password reset link',
  };
}

// ============================================
// RESET PASSWORD ACTION
// ============================================

export async function resetPassword(formData: ResetPasswordInput) {
  const validated = resetPasswordSchema.safeParse(formData);
  
  if (!validated.success) {
    return {
      error: validated.error.errors[0]?.message || 'Invalid input',
    };
  }

  const supabase = await createClient();
  
  const { error } = await supabase.auth.updateUser({
    password: validated.data.password,
  });

  if (error) {
    return { error: error.message };
  }

  revalidatePath('/', 'layout');
  const referer = headers().get('referer');
  let fromAdmin = false;
  if (referer) {
    try {
      fromAdmin = new URL(referer).searchParams.get('from') === 'admin';
    } catch {
      fromAdmin = false;
    }
  }
  const successMessage = '?message=Password updated successfully';
  const destination = fromAdmin
    ? `${getAdminAppUrl()}/login${successMessage}`
    : `/login${successMessage}`;

  redirect(destination);
}

// ============================================
// SOCIAL LOGIN ACTIONS
// ============================================

export async function signInWithGoogle(userType: AcceptedUserType = 'attendee') {
  const appUrl = getAppUrl();
  const supabase = await createClient();
  const normalizedUserType = normalizeUserType(userType) || 'attendee';
  
  const { data, error } = await supabase.auth.signInWithOAuth({
    provider: 'google',
    options: {
      redirectTo: `${appUrl}/auth/callback?user_type=${normalizedUserType}`,
      queryParams: {
        access_type: 'offline',
        prompt: 'consent',
      },
    },
  });

  if (error) {
    return { error: error.message };
  }

  if (data.url) {
    redirect(data.url);
  }

  return { error: 'Failed to initialize Google sign-in' };
}

export async function signInWithGitHub(userType: AcceptedUserType = 'attendee') {
  const appUrl = getAppUrl();
  const supabase = await createClient();
  const normalizedUserType = normalizeUserType(userType) || 'attendee';
  
  const { data, error } = await supabase.auth.signInWithOAuth({
    provider: 'github',
    options: {
      redirectTo: `${appUrl}/auth/callback?user_type=${normalizedUserType}`,
    },
  });

  if (error) {
    return { error: error.message };
  }

  if (data.url) {
    redirect(data.url);
  }

  return { error: 'Failed to initialize GitHub sign-in' };
}

export async function signInWithApple(userType: AcceptedUserType = 'attendee') {
  const appUrl = getAppUrl();
  const supabase = await createClient();
  const normalizedUserType = normalizeUserType(userType) || 'attendee';
  
  const { data, error } = await supabase.auth.signInWithOAuth({
    provider: 'apple',
    options: {
      redirectTo: `${appUrl}/auth/callback?user_type=${normalizedUserType}`,
    },
  });

  if (error) {
    return { error: error.message };
  }

  if (data.url) {
    redirect(data.url);
  }

  return { error: 'Failed to initialize Apple sign-in' };
}

// ============================================
// LOGOUT ACTION
// ============================================

export async function logout() {
  const supabase = await createClient();
  await supabase.auth.signOut();
  revalidatePath('/', 'layout');
  redirect('/');
}

// ============================================
// GET CURRENT USER ACTION
// ============================================

export async function getCurrentUser() {
  const supabase = await createClient();
  
  const { data: { user }, error } = await supabase.auth.getUser();
  
  if (error || !user) {
    return null;
  }

  // Get user metadata to determine type
  const userType = normalizeUserType(user.user_metadata?.user_type);
  
  // Fetch profile based on user type
  if (userType === 'creator') {
    const { data: profile } = await supabase
      .from('photographers')
      .select('*')
      .eq('id', user.id)
      .single();
    
    return {
      ...user,
      userType: 'creator' as const,
      profile,
    };
  } else if (userType === 'attendee') {
    const { data: profile } = await supabase
      .from('attendees')
      .select('*')
      .eq('id', user.id)
      .single();
    
    return {
      ...user,
      userType: 'attendee' as const,
      profile,
    };
  }

  return {
    ...user,
    userType: undefined,
    profile: null,
  };
}
